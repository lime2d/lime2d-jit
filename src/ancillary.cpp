#include "ancillary.h"
#include "App.h"
#include "misc.h"

struct ParsedTxtImage
{
    bool ok = false;
    int w = 0, h = 0;
    std::vector<unsigned char> bytes;
};

static bool mightBeTxtImageDataFile(const fs::path& p)
{
    if (isDotHiddenName(p)) return false;
    if (!hasExtension(p, "txt")) return false;

    std::error_code ec;
    if (!fs::exists(p, ec) || ec) return false;
    if (!fs::is_regular_file(p, ec) || ec) return false;

    return true;
}

static ParsedTxtImage tryParseTxtImage(const fs::path& txtPath)
{
    ParsedTxtImage r;

    std::ifstream f(txtPath);
    if (!f) return r;

    std::vector<std::string> lines;
    std::string line;
    while (std::getline(f, line))
    {
        if (!line.empty() && line.back() == '\r') line.pop_back();
        lines.push_back(line);
    }

    for (const auto& ln : lines)
        if (ln.empty()) return r;

    if (lines.empty()) return r;

    const int w = static_cast<int>(lines[0].size());
    if (w <= 0 || (w % 8) != 0) return r;

    const int h = (int)lines.size();
    for (const auto& ln : lines)
    {
        if ((int)ln.size() != w) return r;
        for (char c : ln)
            if (c != '#' && c != '.') return r;
    }

    const int rowBytes = w / 8;
    r.bytes.assign((size_t)rowBytes * (size_t)h, 0);

    for (int y = 0; y < h; y++)
    {
        for (int x = 0; x < w; x++)
        {
            if (lines[y][x] == '#')
            {
                const int bi = y * rowBytes + (x / 8);
                r.bytes[(size_t)bi] |= (unsigned char)(1u << (x % 8)); // LSB = leftmost pixel
            }
        }
    }

    r.ok = true;
    r.w = w;
    r.h = h;
    return r;
}

static fs::path makeUniqueLuaPathNextTo(const fs::path& source, const fs::path& stem)
{
    fs::path dir = source.parent_path();
    fs::path candidate = dir / (stem.string() + ".lua");
    if (!fs::exists(candidate)) return candidate;

    for (int i = 1; i < 100; i++)
    {
        fs::path c = dir / (stem.string() + "_" + std::to_string(i) + ".lua");
        if (!fs::exists(c)) return c;
    }
    return candidate;
}

bool tryGenerateLuaImageFromTxt(const fs::path& txtPath, TxtImageGenResult& out)
{
    out = TxtImageGenResult{};
    out.sourceTxt = txtPath;

    if (!fs::is_regular_file(txtPath)) return false;

    ParsedTxtImage img = tryParseTxtImage(txtPath);
    if (!img.ok) return false; // Not an actual image data file

    out.recognized = true;
    out.w = img.w;
    out.h = img.h;

    const std::string name = txtPath.stem().string();
    fs::path outPath = makeUniqueLuaPathNextTo(txtPath, txtPath.stem());
    out.outLua = outPath;

    std::ofstream f(outPath, std::ios::trunc);
    if (!f)
    {
        out.error = std::string("Failed to write generated image Lua file: ") + outPath.string();
        out.generated = false;
        return true; // Handled (recognized), but failed to produce output file
    }

    f << "-- Auto-generated by Lime2D from: " << txtPath.filename().string() << "\n";
    f << "lime.defineImage(" << "\"" << name << "\"" << ", " << img.w << ", " << img.h << ", {\n";

    const int rowBytes = img.w / 8;
    for (int y = 0; y < img.h; y++)
    {
        f << "  ";
        for (int x = 0; x < rowBytes; x++)
        {
            int v = (int)img.bytes[(size_t)(y * rowBytes + x)];
            f << v << ",";
        }
        f << "\n";
    }

    f << "})\n";

    out.generated = true;
    return true;
}

std::string formatTxtImageGenReport(
    int txtScanned,
    const std::vector<TxtImageGenResult>& results,
    const std::vector<std::string>& scanWarnings)
{
    int recognized = (int)results.size();
    int ok = 0;
    int failed = 0;
    for (const auto& r : results)
    {
        if (r.generated) ok++;
        else failed++;
    }

    std::ostringstream oss;
    oss <<
        "TXT image import completed.\n\n"
        "Scanned *.txt files: " << txtScanned << "\n"
        "Recognized images:   " << recognized << "\n"
        "Generated *.lua:     " << ok << "\n"
        "Failed:              " << failed << "\n\n";

    if (!scanWarnings.empty())
    {
        oss << "Scan warnings (also written to error.log):\n";
        for (const auto& w : scanWarnings)
            oss << " - " << w << "\n";
        oss << "\n";
    }

    if (!results.empty())
    {
        oss << "Recognized images:\n";
        for (const auto& r : results)
        {
            oss << " - " << r.sourceTxt.string() << "  (" << r.w << "x" << r.h << ")\n";
            oss << "   -> " << r.outLua.string() << (r.generated ? "" : "  [FAILED]") << "\n";
            if (!r.error.empty())
                oss << "      Reason: " << r.error << "\n";
        }
        oss << "\n";
    }

    oss << "Tip: The generated *.lua files call lime.defineImage(...)\n";
    return oss.str();
}

bool processTxtImageFiles(
    const std::vector<fs::path>& droppedRegularFiles,
    const std::vector<std::string>& scanWarnings,
    ScreenInfo& infoScreen,
    Window& wnd)
{
    int txtScanned = 0;
    std::vector<TxtImageGenResult> results;

    for (const auto& p : droppedRegularFiles)
    {
        if (mightBeTxtImageDataFile(p))
        {
            ++txtScanned;
            TxtImageGenResult r;
            if (tryGenerateLuaImageFromTxt(p, r))
            {
                results.push_back(r);
                if (!r.error.empty())
                    logError(r.error);
            }
        }
    }

    if (results.empty())
        return false;

    // Show processing results
    infoScreen.setKind(ScreenInfo::Kind::Info);
    infoScreen.setTitle("--  T X T   T O   L U A  --");
    infoScreen.setMessage(formatTxtImageGenReport(txtScanned, results, scanWarnings));
    wnd.show(&infoScreen);
    return true;
}